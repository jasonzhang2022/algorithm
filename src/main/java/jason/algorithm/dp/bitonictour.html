
<!-- saved from url=(0064)http://www.cs.rit.edu/~rlc/Courses/Algorithms/Project/final.html -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
  <title>Bitonic Traveling Salesman Problem</title>
</head>
<body bgcolor="#f6ffff">
<div style="text-align: center;">
  <div style="text-align: center;">
    <h1>
      4003-515 Programming Project
    </h1>
    <h1>
      Bitonic Traveling Salesman Problem
    </h1>
    <h2>
      Final Project Due: Sunday, February 20<sup>th</sup>, 2011 by midnight
    </h2>
</div>
</div>
  
<hr>

<h2>
  Program Requirements
</h2>
<p>Generate an approximately optimal tour by finding the optimal bitonic tour using a dynamic programming approach. Compute the cost of the approximate tour. If n &lt;= 10 print out the list of X-Y coordinates, the graph as an adjacency matrix, the X-Y coordinates sorted in order of increasing X-coordinate, the L-Table, and the N-table. For all values of n print out the total distance, the tour found, and the runtime for the algorithm.

</p><p>You must also submit with this part of the project a final summary report in MS Word format, called report.doc. The report (5 page minimum) will consist of an overview of the entire project (all four parts), and sections for experimental design, input, output, analysis, and a summary. The analysis section will include plots showing a comparison of the runtimes of the four algorithms with various input sizes, a summary of the performance profile for each of the four algorithms, and a table showing a comparison of the actual and theoretical runtimes for each of the four algorithms. From the table, you should be able to calculate the hidden constant for each of the four algorithms. See the <a href="http://www.cs.rit.edu/~rlc/Courses/Algorithms/Project/project.html">main project page</a> for details concerning the summary report.

</p><p>Recall from our classroom discussion that a bitonic tour is one that starts at the leftmost vertex of the graph (assuming the edge weights are the Euclidean distance between any two vertices), then goes strictly left to right to the rightmost vertex, and then goes strictly right to left back to the starting vertex. The algorithm for finding the optimal bitonic tour on a Euclidean graph has polynomial time complexity. Essentially, the algorithm sorts the list of vertices in order of increasing x-coordinate, and then scans the list from smallest to largest, maintaining optimal possibilities for the two parts of the tour. The algorithm assumes that no two vertices have the same x-coordinate.

</p><hr>

<h2>
  Sample Output
</h2>
 
<p>Below is an example of what the output should look like, assuming the program is run with n = 5 and seed = 100000. Your output should look identical to this output, including spacing and decimal precision, but not including the runtime value. You can check your output for correct formatting by saving this sample <a href="http://www.cs.rit.edu/~rlc/Courses/Algorithms/Project/bitonic">output file</a>, generating your own output file by running your program, and then running the UNIX <code>diff</code> command to compare your output with the sample:

</p><pre>% java BitonicTSP 5 100000 &gt; output
% diff -w output bitonic
</pre>

If nothing prints to the screen after this command other than the runtimes, then your output is formatted correctly.

<p>Note that your program will be tested on multiple values of n and seed not just the values shown here, so be sure to fully test your program, including all error conditions.  Note also that tours always begin and end with vertex 0, and always proceed in a clockwise fashion, starting from vertex 0. 

</p><pre>% java BitonicTSP 5 100000
X-Y Coordinates:
v0: (2,2) v1: (0,1) v2: (4,1) v3: (3,0) v4: (1,3) 

Adjacency matrix of graph weights:

      0      1      2      3      4

0   0.00   2.24   2.24   2.24   1.41  

1   2.24   0.00   4.00   3.16   2.24  

2   2.24   4.00   0.00   1.41   3.61  

3   2.24   3.16   1.41   0.00   3.61  

4   1.41   2.24   3.61   3.61   0.00  

Sorted X-Y Coordinates:
v1: (0,1) v4: (1,3) v0: (2,2) v3: (3,0) v2: (4,1) 

L-Table:
 0.00  2.24  3.65  5.89  7.30 
 0.00  0.00  4.47  6.71  8.12 
 0.00  0.00  0.00  6.81  8.23 
 0.00  0.00  0.00  0.00  9.05 
 0.00  0.00  0.00  0.00  0.00 

N-Table:
-1  0  1  2  3 
-1 -1  0  2  3 
-1 -1 -1  0  3 
-1 -1 -1 -1  2 
-1 -1 -1 -1 -1 

Distance using bitonic: 10.46 for path 0 2 3 1 4 0 
Runtime for bitonic TSP   : 2 milliseconds

</pre>

<p>Below is an example of what the output should look like for n = 13 and seed = 100000: 
</p><pre>% java BitonicTSP 13 100000

Distance using bitonic: 44.03 for path 0 9 6 2 10 7 5 1 12 3 4 8 11 0
Runtime for bitonic TSP   : 10 milliseconds

</pre>

<hr>

<h2>
  Error Conditions
</h2>

<ol>
<li>Missing one or both command line arguments:</li>
<ul><li><code>Usage: java BitonicTSP n seed</code></li></ul>
<li>One or both command line arguments is not an integer:</li>
<ul><li><code>Command line args must be integers</code></li></ul>
<li>Value of n is less than 1:</li>
<ul><li><code>Number of vertices must be greater than 0</code></li></ul>
</ol>

Your program should print the error message to standard output (not standard error) and terminate upon any of these error conditions. No other error condition will be tested for.
<hr>

<h2>
  Submission
</h2>

<p>When you have your program working you can 
submit your source code <b>and your report</b> from your CS account using the following command:

</p><p align="Center">
<code>submit -v grd-515 project-final BitonicTSP.java Graph.java [other source file(s)] </code>

</p><p>***DO NOT FORGET TO SUBMIT THE PROJECT REPORT!***

</p><p>To check if your files were submitted correctly, you can use the following command:
</p><p align="Center">
<code>cksubmit -v grd-515 project-final </code>

</p>
</body>
</html>